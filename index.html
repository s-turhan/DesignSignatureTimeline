<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <title>Design Signature Timeline Generator</title>
    <style>
        :root {
            --px-per-sec: 2;
            --panel-padding: 16px;
        }

        body {
            display: flex;
            font-family: system-ui, sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        #left {
            flex: 4;
            padding: var(--panel-padding);
            overflow-y: auto;
            background: #f9f9f9;
            position: relative;
            scroll-behavior: smooth;
            transition: flex 0.5s ease-in-out;
        }

        #right {
            flex: 2;
            border-left: 1px solid #ccc;
            background: #fff;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: flex 0.5s ease-in-out;
        }

        .bubble {
            max-width: 80%;
            margin: 0.5rem 0;
            padding: 0.75rem;
            border-radius: 10px;
            float: left;
            clear: both;
            background: #eaeaea;
            position: relative;
            transition: box-shadow 0.2s;
        }

        .bubble.highlight {
            box-shadow: 0 0 8px 2px #007bff;
        }

        .speaker {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }

        .speaker .edit {
            text-decoration: underline;
        }

        .speaker .arrow, .speaker .edit {
            opacity: 0;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .speaker:hover .arrow, .speaker:hover .edit {
            opacity: 1;
        }

        .msg-controls {
            position: absolute;
            bottom: 4px;
            right: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .bubble:hover .msg-controls {
            opacity: 1;
        }

        .msg-controls .edit {
            text-decoration: underline;
            cursor: pointer;
        }

        .meta {
            font-size: 0.75rem;
            color: #555;
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .process-tag {
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            color: #fff;
            cursor: pointer;
        }

        #timelineWrap {
            padding: var(--panel-padding);
            overflow-y: auto;
            flex: 1;
            border-bottom: 1px solid #eee;
            transition: flex 0.5s ease-in-out;
        }

        .timeline-item {
            margin: 4px 0;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .timeline-item.active {
            background: #e6f0ff;
            font-weight: 600;
            color: #0057c2;
        }

        .viz-body {
            display: flex;
            width: 100%;
            max-height: 40%;
            overflow-y: auto;
            padding: 0 var(--panel-padding);
            gap: 20px;
        }

        /* Speakers column */
        #scale {
            flex: 1;
            position: relative;
            /* Reserve gutter for time labels without shifting the axis origin */
            padding-left: 90px; /* label gutter */
        }

        #scale .segment {
            left: 10px; /* offset right so they don’t overlap tick labels */
            transform: none;
        }

        #viz-header {
            overflow: visible;
            padding-bottom: 8px; /* space between legend and figure */
        }

        /* Categories container and columns */
        .process-timeline {
            flex: 1; /* equal with #scale */
            display: flex; /* columns side by side */
            gap: 20px;
        }

        .process-timeline .column {
            flex: 1;
            position: relative;
            /* no horizontal padding; axis origin stays at x=0 inside .axis */
        }

        /* Axis wrapper: the shared origin for ticks/segments in each column */
        .axis {
            position: relative;
            height: var(--timeline-height); /* set via JS */
        }

        /* The vertical axis line at x=0 inside each axis */
        .axis-line {
            position: absolute;
            left: 0; /* origin */
            width: 2px;
            height: 100%;
            background: #eee;
        }

        /* Ticks in the scale axis */
        .tick {
            position: absolute;
            left: 0;
            right: 0; /* extend full width */
            border-top: 1px solid #777;
            height: 0;
        }

        .tick.major {
            border-top-color: #333;
        }

        .tick.major .label {
            position: absolute;
            left: -80px; /* draws into the gutter reserved by #scale padding */
            top: -8px;
            width: 76px;
            text-align: right;
        }

        /* Segments centered on the axis line */
        .segment {
            position: absolute;
            left: 0; /* axis origin */
            transform: translateX(-50%); /* center over the axis line */
            width: 12px; /* adjust as needed */
            border-radius: 6px;
            opacity: 0.9;
        }

        /* Legend alignment: match column distribution */
        #process-legend {
            display: flex;
            gap: 20px;
        }

        #process-legend > div {
            flex: 1;
            text-align: center;
            overflow: hidden; /* prevent clipping */
        }

        #generateBtn {
            margin-bottom: 8px;
            padding: 6px 12px;
        }

        #legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            font-size: 0.8rem;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #fafafa;
        }

        .chip .color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
        }

        .inline-input {
            font: inherit;
            padding: 2px 4px;
            border: 1px solid #bbb;
            border-radius: 4px;
            background: #fff;
        }
    </style>
</head>
<body>
<div id="left">
    <h2>Transcript</h2>
    <input id="fileInput" type="file" accept=".doc,.docx"/>
    <div id="chat"></div>
</div>
<div id="right">
    <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2>Design Signature</h2>
        <div id="user-info" style="font-size:0.9em; color:#666;"></div>
    </div>
    <div id="timelineWrap">
        <div id="timeline"></div>
    </div>

    <div id="viz-header" style="padding: var(--panel-padding) var(--panel-padding) 0 var(--panel-padding);">
        <div id="legend"></div>
        <div id="process-legend">
        </div>
    </div>

    <div id="viz-body" class="viz-body">
        <div id="scale">
            <div class="axis">
                <div class="axis-line"></div>
                <!-- ticks and speaker segments will be appended here -->
            </div>
        </div>

        <div id="process-timeline" class="process-timeline">
            <!-- in JS, each category column will be:
            <div class="column">
              <div class="axis">
                <div class="axis-line"></div>
                category segments appended here
        </div>
    </div>
    -->
        </div>
    </div>

    <div style="padding: var(--panel-padding); border-top: 1px solid #eee;">
        <button id="generateBtn">Generate Design Signature Timeline</button>
        <button id="downloadBtn" style="margin-left: 8px;">Download as PNG</button>
    </div>
</div>

<script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
    let entries = [];
    let startSec = 0, endSec = 0;
    const speakerColors = {};
    const categoryColors = {PROB: "#d9534f", SOLN: "#5cb85c"};
    let scrollSyncHandler;

    async function processFile(file) {
        if (!file) return;
        if (!file.name.endsWith('.docx') && !file.name.endsWith('.doc')) {
            alert('Please upload a .doc or .docx file.');
            return;
        }

        document.body.style.cursor = 'wait';

        try {
            const arrayBuffer = await file.arrayBuffer();
            const {value: html} = await mammoth.convertToHtml({arrayBuffer});
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const sections = extractH1Sections(doc);
            const transcriptText = getSection(sections, 'Transcript');
            entries = parseTranscript(transcriptText);

            if (!entries.length) {
                alert("Could not parse transcript from the file.");
                return;
            }

            entries.forEach(e => e.process_category = "");
            startSec = toSeconds(entries[0].time);
            endSec = toSeconds(entries[entries.length - 1].time);
            assignSpeakerColors();
            renderAll();

            // Automatically trigger timeline generation
            await generateBtnClicked();

        } catch (err) {
            console.error('Error processing file:', err);
            alert('An error occurred while processing the file.');
        } finally {
            document.body.style.cursor = 'default';
        }
    }

    // Drag and drop listeners
    document.body.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.stopPropagation();
    });

    document.body.addEventListener('dragleave', (e) => {
        e.preventDefault();
        e.stopPropagation();
    });

    document.body.addEventListener('drop', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            await processFile(files[0]);
        }
    });

    fileInput.addEventListener('change', async e => {
        const file = e.target.files[0];
        await processFile(file);
    });

    async function generateTimeline() {
        try {
            const response = await fetch('/api/categorize', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({entries})   // ensure `entries` is defined
            });

            if (!response.ok) {
                const text = await response.text();
                console.error('API returned error:', response.status, text);
                return;
            }

            const data = await response.json();

            if (!data.success) {
                console.error('Categorize API error:', data.error);
                return;
            }

            console.log('Categorization response:', data);

            data.results.forEach((item, i) => {
                if (item.__debugPrompt) {
                    console.log("DEBUG PROMPT:\n", item.__debugPrompt);
                    // optionally show in a <pre id="debugPrompt"></pre>
                    const el = document.getElementById("debugPrompt");
                    if (el) el.textContent = item.__debugPrompt;
                } else if (item.__debugApiResponse) {
                    console.log("DEBUG API RESPONSE:\n", item.__debugApiResponse);
                    const el = document.getElementById("debugApiResponse");
                    if (el) el.textContent = item.__debugApiResponse;
                } else if (entries[i]) {
                    entries[i].process_category = item.category || '';
                }
            });

            renderAll();
        } catch (err) {
            console.error('Error calling categorize API:', err);
        }
    }

    async function generateBtnClicked() {
        generateBtn.disabled = true;
        generateBtn.textContent = "Processing...";

        try {
            await generateTimeline();
            document.getElementById('left').style.flex = '1';
            document.getElementById('right').style.flex = '3';
            document.getElementById('timelineWrap').style.flex = '1';
        } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = "Update Design Signature Timeline";
            downloadBtn.hidden = false;
        }
    }

    generateBtn.addEventListener('click', async () => {
        if (entries.length === 0) {
            alert("Please upload a transcript file first.");
            return;
        }
        await generateBtnClicked();
    });

    downloadBtn.addEventListener('click', downloadPlot);
    downloadBtn.hidden = true;

    function downloadPlot() {
        if (!entries.some(e => e.process_category)) {
            alert("Please generate the timeline first to categorize entries.");
            return;
        }

        const prob_x = [];
        const prob_base = [];
        const soln_x = [];
        const soln_base = [];

        for (let i = 0; i < entries.length; i++) {
            const entry = entries[i];
            if (entry.process_category === 'PROB' || entry.process_category === 'SOLN') {
                const start = toSeconds(entry.time);
                const end = (i < entries.length - 1) ? toSeconds(entries[i + 1].time) : endSec;
                const duration = end - start;

                if (entry.process_category === 'PROB') {
                    prob_x.push(duration);
                    prob_base.push(start);
                } else { // SOLN
                    soln_x.push(duration);
                    soln_base.push(start);
                }
            }
        }

        const tickvals = [];
        const ticktext = [];
        const duration = endSec - startSec;
        const step = duration > 600 ? 300 : 60;
        for (let t = 0; t <= duration; t += step) {
            tickvals.push(startSec + t);
            ticktext.push(fmtTime(startSec + t));
        }
        if (tickvals[tickvals.length - 1] < endSec) {
            tickvals.push(endSec);
            ticktext.push(fmtTime(endSec));
        }

        const prob_trace = {
            x: prob_x,
            y: Array(prob_x.length).fill(0),   // numeric position for PROB
            base: prob_base,
            name: 'PROB',
            type: 'bar',
            orientation: 'h',
            marker: {color: '#1f77b4'}
        };

        const soln_trace = {
            x: soln_x,
            y: Array(soln_x.length).fill(1),   // numeric position for SOLN
            base: soln_base,
            name: 'SOLN',
            type: 'bar',
            orientation: 'h',
            marker: {color: '#ff7f0e'}
        };

        const data = [soln_trace, prob_trace];

        const layout = {
            title: 'Design Signature Timeline',
            xaxis: {
                title: 'Time',
                tickvals: tickvals,
                ticktext: ticktext,
                range: [startSec, endSec],
                showgrid: true,          // vertical grid lines
                zeroline: false
            },
            yaxis: {
                tickvals: [0, 1],        // numeric positions
                ticktext: ['PROB', 'SOLN'],
                automargin: true,
                showgrid: true,          // horizontal grid lines
                zeroline: false
            },
            bargap: 0.2,
            showlegend: false
        };

        const plotDiv = document.createElement('div');
        plotDiv.style.width = '1200px';
        plotDiv.style.height = '400px';
        plotDiv.style.position = 'absolute';
        plotDiv.style.left = '-9999px';
        document.body.appendChild(plotDiv);

        Plotly.newPlot(plotDiv, data, layout).then(gd => {
            Plotly.toImage(gd, {format: 'png', width: 1200, height: 400})
                .then(dataUrl => {
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = 'design_signature_timeline.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    document.body.removeChild(plotDiv);
                });
        });
    }

    function extractH1Sections(doc) {
        const h1s = [...doc.querySelectorAll('h1')];
        const sections = {};
        for (let i = 0; i < h1s.length; i++) {
            const title = h1s[i].textContent.trim();
            const content = [];
            let node = h1s[i].nextSibling;
            while (node && !(node.nodeType === 1 && node.tagName.toLowerCase() === 'h1')) {
                if (node.nodeType === 1) content.push(node.textContent.trim());
                node = node.nextSibling;
            }
            sections[title] = content.join('\n');
        }
        return sections;
    }

    function getSection(sections, title) {
        const keys = Object.keys(sections);
        const exact = keys.find(k => k.toLowerCase() === title.toLowerCase());
        if (exact) return sections[exact];
        const partial = keys.find(k => k.toLowerCase().includes(title.toLowerCase()));
        return partial ? sections[partial] : '';
    }

    function parseTranscript(raw) {
        const lines = raw.split(/\r?\n/).map(l => l.trim());
        const result = [];
        let current = null;
        const regex = /^(\d{2}:\d{2}:\d{2})\s+(.+)$/;
        for (const line of lines) {
            if (!line) continue;
            const m = line.match(regex);
            if (m) {
                if (current) result.push(current);
                current = {time: m[1], speaker: m[2], text: ''};
            } else if (current) {
                current.text += (current.text ? ' ' : '') + line;
            }
        }
        if (current) result.push(current);
        return result;
    }

    function toSeconds(t) {
        const [h, m, s] = t.split(':').map(Number);
        return h * 3600 + m * 60 + s;
    }

    function fmtTime(sec) {
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = sec % 60;
        const pad = n => String(n).padStart(2, '0');
        return `${pad(h)}:${pad(m)}:${pad(s)}`;
    }

    function getSpeakers() {
        return [...new Set(entries.map(e => e.speaker))];
    }

    function assignSpeakerColors() {
        getSpeakers().forEach((spk, i) => {
            if (!speakerColors[spk]) {
                const hue = (i * 137) % 360; // golden angle
                speakerColors[spk] = `hsl(${hue},80%,90%)`;
            }
        });
    }

    function renderAll() {
        const pxPerSec = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--px-per-sec')) || 2;
        const duration = Math.max(0, endSec - startSec);
        const totalHeight = Math.max(200, duration * pxPerSec);

        document.documentElement.style.setProperty('--timeline-height', totalHeight + 'px');

        renderChat();
        renderTimeline();
        renderScale(pxPerSec, duration);
        renderLegend();
        renderProcessTimeline(pxPerSec, duration);
        setupScrollSync();
    }

    function renderChat() {
        chat.innerHTML = '';
        entries.forEach((e, idx) => {
            const div = document.createElement('div');
            div.className = 'bubble';
            div.style.background = speakerColors[e.speaker] || '#eaeaea';
            div.id = 'msg-' + idx;
            div.innerHTML = `
      <div class="speaker">
        <span class="arrow arrow-left">&lt;</span>
        <span class="name">${escapeHtml(e.speaker)}</span>
        <span class="edit">✎</span>
        <span class="arrow arrow-right">&gt;</span>
      </div>
      <div class="text">${escapeHtml(e.text)}</div>
      <div class="meta">
        <span class="time">${e.time}</span>
        ${e.process_category ? `<span class="process-tag" style="background:${categoryColors[e.process_category]}">${e.process_category}</span>` : ''}
      </div>
      <div class="msg-controls"><span class="edit">✎</span></div>
    `;
            // Speaker controls
            div.querySelector('.arrow-left').onclick = () => cycleSpeaker(idx, -1);
            div.querySelector('.arrow-right').onclick = () => cycleSpeaker(idx, 1);
            div.querySelector('.speaker .edit').onclick = () => editSpeaker(idx, div);
            // Message edit
            div.querySelector('.msg-controls .edit').onclick = () => editMessage(idx, div);
            // Process tag edit
            const processTag = div.querySelector('.process-tag');
            if (processTag) {
                processTag.onclick = (ev) => showCategoryMenu(idx, ev.target);
            }
            chat.appendChild(div);
        });
        chat.appendChild(Object.assign(document.createElement('div'), {style: 'clear:both'}));
    }

    function renderTimeline() {
        timeline.innerHTML = '';
        entries.forEach((e, idx) => {
            const row = document.createElement('div');
            row.className = 'timeline-item';
            row.innerHTML = `<span>${e.time} — ${escapeHtml(e.speaker)}</span>`;
            row.onclick = () => scrollBubbleIntoView(idx);
            timeline.appendChild(row);
        });
    }

    function renderScale(pxPerSec, duration) {
        const scaleEl = document.getElementById('scale');
        scaleEl.innerHTML = '';

        const axis = document.createElement('div');
        axis.className = 'axis';

        const axisLine = document.createElement('div');
        axisLine.className = 'axis-line';
        axis.appendChild(axisLine);

        for (let t = 0; t <= duration; t += 10) {
            const y = t * pxPerSec;
            const tick = document.createElement('div');
            tick.className = 'tick';
            tick.style.top = y + 'px';
            if (t % 60 === 0) {
                tick.classList.add('major');
                const label = document.createElement('div');
                label.className = 'label';
                label.textContent = fmtTime(startSec + t);
                tick.appendChild(label);
            }
            axis.appendChild(tick);
        }

        for (let i = 0; i < entries.length; i++) {
            const curT = toSeconds(entries[i].time);
            const nextT = i < entries.length - 1 ? toSeconds(entries[i + 1].time) : endSec;
            const yTop = (curT - startSec) * pxPerSec;
            const height = Math.max(2, (nextT - curT) * pxPerSec);

            const seg = document.createElement('div');
            seg.className = 'segment';
            seg.style.top = yTop + 'px';
            seg.style.height = height + 'px';
            seg.style.background = speakerColors[entries[i].speaker] || '#ccc';
            axis.appendChild(seg);
        }

        scaleEl.appendChild(axis);
    }

    function renderProcessTimeline(pxPerSec, duration) {
        const legendContainer = document.getElementById('process-legend');
        const timelineContainer = document.getElementById('process-timeline');
        legendContainer.innerHTML = '';
        timelineContainer.innerHTML = '';

        const categories = Object.keys(categoryColors);

        categories.forEach(cat => {
            const legendEl = document.createElement('div');
            legendEl.textContent = cat;
            legendEl.style.color = categoryColors[cat];
            legendEl.style.fontWeight = 'bold';
            legendEl.style.flex = '1';
            legendEl.style.textAlign = 'center';
            legendContainer.appendChild(legendEl);

            const column = document.createElement('div');
            column.className = 'column';

            const axis = document.createElement('div');
            axis.className = 'axis';

            const axisLine = document.createElement('div');
            axisLine.className = 'axis-line';
            axis.appendChild(axisLine);

            for (let i = 0; i < entries.length; i++) {
                if (entries[i].process_category === cat) {
                    const curT = toSeconds(entries[i].time);
                    const nextT = i < entries.length - 1 ? toSeconds(entries[i + 1].time) : endSec;
                    const yTop = (curT - startSec) * pxPerSec;
                    const height = Math.max(2, (nextT - curT) * pxPerSec);

                    const seg = document.createElement('div');
                    seg.className = 'segment';
                    seg.style.top = yTop + 'px';
                    seg.style.height = height + 'px';
                    seg.style.background = categoryColors[cat];
                    seg.style.cursor = 'pointer';

                    seg.onmouseover = () => {
                        const bubble = document.getElementById('msg-' + i);
                        if (bubble) bubble.classList.add('highlight');
                    };
                    seg.onmouseout = () => {
                        const bubble = document.getElementById('msg-' + i);
                        if (bubble) bubble.classList.remove('highlight');
                    };
                    seg.onclick = () => scrollBubbleIntoView(i);

                    axis.appendChild(seg);
                }
            }

            column.appendChild(axis);
            timelineContainer.appendChild(column);
        });
    }

    function renderLegend() {
        const legend = document.getElementById('legend');
        legend.innerHTML = '';
        getSpeakers().forEach(spk => {
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.innerHTML = `<span class="color" style="background:${speakerColors[spk]}"></span>${escapeHtml(spk)}`;
            legend.appendChild(chip);
        });
    }

    function showCategoryMenu(idx, target) {
        const menu = document.createElement('div');
        menu.style.position = 'absolute';
        menu.style.background = 'white';
        menu.style.border = '1px solid #ccc';
        menu.style.borderRadius = '4px';
        menu.style.padding = '4px';
        menu.style.zIndex = '100';

        const categories = Object.keys(categoryColors);

        categories.forEach(cat => {
            const item = document.createElement('div');
            item.textContent = cat || 'None';
            item.style.padding = '4px 8px';
            item.style.cursor = 'pointer';
            item.onmouseover = () => item.style.background = '#f0f0f0';
            item.onmouseout = () => item.style.background = 'white';
            item.onclick = () => {
                entries[idx].process_category = cat;
                document.body.removeChild(menu);
                renderAll();
            };
            menu.appendChild(item);
        });

        document.body.appendChild(menu);
        const rect = target.getBoundingClientRect();
        menu.style.left = rect.left + 'px';
        menu.style.top = rect.bottom + 'px';

        setTimeout(() => {
            const clickOutsideHandler = (e) => {
                if (!menu.contains(e.target)) {
                    document.body.removeChild(menu);
                    document.removeEventListener('click', clickOutsideHandler);
                }
            };
            document.addEventListener('click', clickOutsideHandler);
        }, 0);
    }

    function scrollBubbleIntoView(idx) {
        const bubble = document.getElementById('msg-' + idx);
        if (!bubble) return;
        const targetTop = bubble.offsetTop - 8;
        left.scrollTo({top: targetTop, behavior: 'smooth'});
    }

    function setupScrollSync() {
        if (scrollSyncHandler) {
            left.removeEventListener('scroll', scrollSyncHandler);
        }
        const items = [...timeline.querySelectorAll('.timeline-item')];
        const bubbles = entries.map((_, idx) => document.getElementById('msg-' + idx));
        scrollSyncHandler = () => {
            let activeIdx = 0;
            for (let i = 0; i < bubbles.length; i++) {
                if (bubbles[i] && bubbles[i].offsetTop < left.scrollTop + 100) activeIdx = i;
            }
            items.forEach(el => el.classList.remove('active'));
            if (items[activeIdx]) {
                items[activeIdx].classList.add('active');
                items[activeIdx].scrollIntoView({block: 'nearest'});
            }
        };
        left.addEventListener('scroll', scrollSyncHandler);
    }

    function editSpeaker(idx, bubbleEl) {
        const current = entries[idx].speaker;
        const nameEl = bubbleEl.querySelector('.name');
        const input = document.createElement('input');
        input.type = 'text';
        input.value = current;
        input.className = 'inline-input';
        nameEl.replaceWith(input);
        input.focus();
        input.onkeydown = ev => {
            if (ev.key === 'Enter') {
                const newName = input.value.trim() || current;
                entries.forEach(e => {
                    if (e.speaker === current) e.speaker = newName;
                });
                if (!speakerColors[newName]) {
                    const idxColor = Object.keys(speakerColors).length;
                    speakerColors[newName] = `hsl(${(idxColor * 137) % 360},80%,90%)`;
                }
                renderAll();
            } else if (ev.key === 'Escape') {
                renderAll();
            }
        };
    }

    function cycleSpeaker(idx, dir) {
        const speakers = getSpeakers();
        const cur = entries[idx].speaker;
        let i = speakers.indexOf(cur);
        if (i === -1) i = 0;
        i = (i + dir + speakers.length) % speakers.length;
        const newName = speakers[i];
        entries[idx].speaker = newName;
        renderAll();
    }

    function editMessage(idx, bubbleEl) {
        const textEl = bubbleEl.querySelector('.text');
        const timeEl = bubbleEl.querySelector('.meta .time');

        // Create inputs
        const txtInput = document.createElement('textarea');
        txtInput.className = 'inline-input';
        txtInput.style.width = '100%';
        txtInput.value = entries[idx].text;

        const timeInput = document.createElement('input');
        timeInput.className = 'inline-input';
        timeInput.type = 'text';
        timeInput.value = entries[idx].time;
        timeInput.placeholder = 'HH:MM:SS';

        textEl.replaceWith(txtInput);
        timeEl.replaceWith(timeInput);
        txtInput.focus();

        const save = () => {
            const newText = txtInput.value.trim();
            const newTime = timeInput.value.trim();
            if (!/^\d{2}:\d{2}:\d{2}$/.test(newTime)) {
                alert('Invalid time format. Use HH:MM:SS.');
                return;
            }
            entries[idx].text = newText;
            entries[idx].time = newTime;
            startSec = toSeconds(entries[0].time);
            endSec = toSeconds(entries[entries.length - 1].time);
            renderAll();
        };
        const cancel = () => renderAll();

        txtInput.addEventListener('keydown', ev => {
            if (ev.key === 'Enter' && !ev.shiftKey) {
                ev.preventDefault();
                save();
            } else if (ev.key === 'Escape') {
                cancel();
            }
        });
        timeInput.addEventListener('keydown', ev => {
            if (ev.key === 'Enter') {
                save();
            } else if (ev.key === 'Escape') {
                cancel();
            }
        });
    }

    function escapeHtml(str) {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }
</script>
</body>
</html>
